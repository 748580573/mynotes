# 一种既不用加锁也能够实现懒加载的单例模式

````
public class Singleton {

    private static Singleton instance;

    private Vector v;

    private boolean inUse;

    private Singleton(){
        v = new Vector();
        v.addElement(new Object());
        inUse = true;
    }

    public static class Inner{

        private static Singleton singleton = new Singleton();
    }

    public static Singleton getInstance(){
        return Inner.singleton;
    }
}
````
另外还有3中方式，自己去网上查


# 售卖火车票案例

````
/**
 * 有N张火车票，每张票都有一个编号
 * 同时有10个窗口对外售票
 * 请写一个模拟程序
 *
 *
 * 分析下面程序可能产生哪些问题
 * 重复销售？超量销售
 */

public class Test {

    static List<String> tickets = new ArrayList<>();

    static {
        for (int i = 0;i < 10000;i++){
            tickets.add("票编号：" + i);
        }
    }

    public static void main(String[] args) throws Exception {
        for (int i = 0;i < 10;i++){
            new Thread(() -> {
                System.out.println("售票了--" + tickets.remove(0));
            }).start();
        }
    }
}
````

这断代码会出现两个问题，火车票的重寿和超售，众所周知ArrayList的remove方法并不是同步的，所以会出现多个线程在同一时刻去出售同一张票的情况，这就是重售的情形。当线程A刚执行完remove后，线程B执行remove会发现票售空了，就会出现超售的情况，抛出数组越界的异常。



````
public class Test {

    static Vector<String> tickets = new Vector<>();

    static {
        for (int i = 0;i < 10000;i++){
            tickets.add("票编号：" + i);
        }
    }

    public static void main(String[] args) throws Exception {
        for (int i = 0;i < 10;i++){
            new Thread(() -> {
			    if(tickets.size() < 0)	
                System.out.println("售票了--" + tickets.remove(0));
            }).start();
        }
    }
}
````
将ArrayList改为Vector后，同样也会出新问题

