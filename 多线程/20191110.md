# 生产者消费者


````
public class MyContainer<T> {

    final private LinkedList<T> list = new LinkedList<>();
    final private int Max = 10;    //最多10个元素
    private int count = 0;

    public synchronized void put(T t){
        while (list.size() == Max){      //想想这里为什么用while而不是if ①
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        list.add(t);
        ++count;
        this.notifyAll();          //想想这里为啥用notifyAll而不用notify ②
    }

    public synchronized T get(){
        T t = null;
        while (list.size() == 0){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        t = list.poll();
        --count;
		this.notifyAll();
        return t;
    }
}
````

在①处用while不用If,是防止出现这样的问题，比如有A、B两个线程调用put方法，发现现在list已经满了，过儿一会有个线程从list中拿走了一个元素，并试图并释放锁，然后A拿到锁后向list里添加一个元素，这时重点来了，如果此时B拿到了锁，那么B又会向list里添加元素，这样就出错了。  
在②中如果用notify，那么他只会唤醒一个线程，如果这个线程是生产者线程，那么他发现list已满就会又wait(),这样会造成资源和时间的浪费。所以一般只使用notiyall而不用notify