# 一个同步方法调用另外一个同步方法

## 子类和父类享有同一个锁标识，子类调用父类的synchronized(this)同步方法，锁可重入



````
import java.util.concurrent.TimeUnit;

public class A {

    public synchronized void test(){
        System.out.println("this is a " + Thread.currentThread().getName());
        try {
            TimeUnit.SECONDS.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

````

````
public class B extends A {

    @Override
    public synchronized void test() {
        System.out.println("this is b" + Thread.currentThread().getName());
        super.test();
    }

    public void test2(){
        super.test();
    }
}
````

若有两个线程，一个线程Thread1去访问B对想的test2()方法，一个线程Thread2去访问B对象  
的test()方法，Thread1先运行，Thread2后运行，这里会出现Thread2方法等待Thread1运行的情况，
着说明Thread1访问test2()方法所需有的锁，与Thread2方法test()方法所需的锁相同，由此可推论  
出**子类和父类享有同一个锁标识**

## 从线程抛出异常，线程会释放锁。


# volatile  赋予变量线程可见性
每当线程运行时，就会分配一块属于自己的内存，线程便会去堆里面拷贝自己所需要的变量并缓存起来， 
然后线程在运行的时候便会去自己的缓存里读取所需要的变量，那么是不是线程所缓存的变量，比如说  
变量a和堆中的变量a就无关系了呢？我们举一个例，比如现在有个线程ThreadA，它要运行对象T的test()  
方法，此时线程A就会去拷贝T中的所使用到变量running，线程ThreadA在运行m()方法时，就会去自己的缓  
存里读取running的值，此时如果有别的线程修改running的值的话，线程ThreadA可能是感知不到running被  
修改了，此时如果用volatile修饰running变量的话，running被修改后ThreadA便能感知到。
````
import java.util.concurrent.TimeUnit;

public class T {

    public boolean running = true;

    public void m(){
        while (running){
            
        }
        System.out.println("结束");
    }
}
````