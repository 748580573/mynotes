# volatile只保证数据可见性，不保证数据一致性
````
public class Test {

    volatile int count = 0;

    void m(){
        for (int i = 0;i < 10000;i++){
            count++;
        }
    }

    public static void main(String[] args) throws Exception {

        ExecutorService service = Executors.newCachedThreadPool();
        Test test = new Test();
        List<Thread> threads = new ArrayList<>();
        for (int i = 0;i < 10;i++){
            threads.add(new Thread(test::m,"Thread" + i));
        }
        threads.forEach(thread -> thread.start());
        threads.forEach(thread -> {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(test.count);
    }
}
````
上面的代码中，一共起了10个线程，每个线程都尝试取将count加1W，但是再实际情况中，比如Thread1在对count加了100  
的时候，线程Thread2才开始启动，Thread2先将count的值读入自己的缓存中（valatile保证可见性），然后对count加1，  
但是与此同时Thread1也在对count进行加一，虽然Thread1宇Thread2都对count加了1，但是由于他们都是在count+1前进行  
加法的，就是说Thread1对count+1的结果还没有写回堆中，Thread2看到的也只有count=100,所以count的值最后变为了101  
而不是理想情况中的102(volatile不保证数据一致性),也就是说valatile不保证对变量的操作为原子操作。

## 锁定某个对象object，如果修改对象object的某个属性放生改变不会影响到锁的使用，但是如果修改object的引用对象，  
则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象。

````
public class Test {

    Object object = new Object();

    void m(){
        synchronized (object){
            while (true){
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
            }
        }
    }

    public static void main(String[] args) throws Exception {

        ExecutorService service = Executors.newCachedThreadPool();
        Test test = new Test();
        new Thread(test::m,"t1").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(test::m,"t2").start();

        test.object = new Object();

    }
}
````
本来在上面代码中，线程t2应该事永远也访问不到m()方法的，但此时我们将test.object指向了另一个对象，t2便能够访问m()  
m()方法了，这说明线程获取的堆中对象的锁，栈中引用变量的“锁”，我们可以通过对引用变量加final关键子来处理这个问题。

## 不要以字符串常量做为锁定的对象，这样可能在无意间造成死锁。

````
public class Test {

    String str1 = "hello";

    String str2 = "hello";

    void m1(){
        synchronized (str1){
            while (true){
                System.out.println("hello1");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    void m2(){
        synchronized (str2){
            while (true){
                System.out.println("hello2");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        Test test = new Test();
        new Thread(test::m1,"t1").start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(test::m1,"t2").start();

        synchronized (Test.class){
            Test.class.wait();
        }
    }
}
````
运行完上面代码后，会发现线程t2永远也没有运行的机会。为什么呢？是因为线程t1会去获取str1的对象锁，线程t2回去获取str2的对象锁，  
但是在**java内存模型中，相同的字符串常量指向的是同一个对对象**，所以t1与t2实际上要获取的是同一个锁，现在t1把锁拿了但不释放  
t2自然就拿不到锁，就无法运行了。

