# MySQL事务

## 简介

提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

## Isolation隔离性

当数据库上有多个事务同时执行的时候，就可能出现脏读(dirty read)、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这个问题，就有了“隔离级别”的概念。

* 脏读：读到其他事务未提交的数据；
* 不可重复读：前后读取的记录内容不一致；
* 幻读：前后读取的记录数据不一致

在隔离级别中，首先需要明确的一点就是隔离级别越严格，效率越低。SQL标准的事务隔离级别包括：读未提交（read uncommited)、读提交（read committed）、可重复读（repeatable read）和串行化(serializable)。

* 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到，即别人改数据的事务尚未提交，我在我的事务中也能读到。
* 读提交：一个事务提交后，它做的变更才会被其他事务看到，即别人改数据的事务已经提交，我在我的事务中才能读到
* 可重复读：一个事务执行的过程中看到的数据，即别人改数据的事务已经提交，我在我的事务中也不去读。
* 串行化：：对于对同一行记录的操作，“写”会加“写锁”，“读”会加“读锁”，即当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才继续执行。我的事务尚未提交，别人就别想改数据

其中“读提交”和“可重复读”比较难理解，下面举几个例子来说明：

````shell
mysql > create table person(name varchar) engine=InnoDB;
mysql > insert into person(name) values("zhangsan")
````



|     事务A      |       事务B        |
| :------------: | :----------------: |
|    启动事务    |      启动事务      |
|  查询得到值1   |                    |
|                | 查询得到值zhangsan |
|                | 将zhangsan改为lisi |
| 查询，得到值V1 |                    |
|                |     提交事务B      |
| 查询，得到值V2 |                    |
|   提交事务A    |                    |
| 查询，得到值V3 |                    |

我们来看看在不同的隔离级别下，V1,V2,V3的值会是什么呢？

* 若隔离级别是“读未提交”，则V1的值lisi。这个时候事务B虽然还没有提交，但是结果已经被A看到了。因此V2，V3也是lisi。
* 若隔离级别是“读提交”，则V1的值是zhangsan，V2，V3的值是lisi。
* 若隔离级别是“可重复读”，则V1,V2的值都是zhangsan，V3的值是lisi，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
* 若隔离级别是“串行化”，则在事务B执行“将zhangsan改成lisi”的时候，会被锁住。因为事务A先执行查询，因此只能等到A事务执行完后才会去执行B事务的事务，因此V1、V2的值是zhangsan，V3的值是lisi。串行化只有在加『读锁』或者「写锁」的时候才会尝试加锁。而不是事务一开始就进行加锁。



在实现上，数据库是以创建视图的方式来区别几种隔离级别的。

* 隔离级别是“读提交”，视图是在每个语句前创建的，所以在“读提交”级别下，一个事务是可以看到另一个事务已经提交的内容，因为它在每一次查询都会冲i性能给与最新的数据创建一个新的MVCC视图。
* 隔离级别是“可重复读”，视图实实在开始事务的时候创建好了，这个视图会一直使用，直到该事务结束。这里需要注意的是不同的隔离级别他们的一致性事务视图创建的时间点是不同的。
* 隔离级别是“串行话”，直接锁表。

##  设置事务等级

说了这么多，那么怎么去调整mysql的事务等级呢？

1. 全局修改，修改mysql.ini配置文件，在最后加上

````shell
1 #可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.
2 [mysqld]
3 transaction-isolation = REPEATABLE-READ
````

这里全局默认是REPEATABLE-READ,其实MySQL本来默认也是这个级别

2. 对当前session修改，在登录mysql客户端后，执行命令：

````shell
set transcation isolation level read uncommitted;
````



要记住mysql有一个autocommit参数，默认是on，他的作用是每一条单独的查询都是一个事务，并且自动开始，自动提交（执行完以后就自动结束了，如果你要适用select for update，而不手动调用 start transaction，这个for update的行锁机制等于没用，因为行锁在自动提交后就释放了），所以事务隔离级别和锁机制即使你不显式调用start transaction，这种机制在单独的一条查询语句中也是适用的，分析锁的运作的时候一定要注意这一点



## 事务隔离的实现

在MySQL使用InnoDB，每一次更新操作都会对应的记录一条回滚日志(undo log）。通过回滚操作，就可以恢复前一条数据的值。比如将1每次加1，一直到4位置，则回滚记录就会记录如下图的链表。

![](./img/transcation/1.png)

当前的值是4，在查询这条记录的时候，不同的事务有着自己的read-view。在视图read-viewA、read-viewB、read-viewC、read-viewD这个记录分别未4、3、2、1。同一条记录在数据库中有着多个版本，即数据库的多版本控制(MVCC)。对于视图C要想得到2，就必须从版本链上进行回滚，即从4开始回滚找到`属于自己`的版本2。即使现在有另外一个事务，将4改为5，也不会影响到其他read-view读取这条记录的结果，这个新的事务跟其他事务不是冲突的。

## 回滚过期

回滚日志总不能一直保留的，那么什么时候可以去删除它呢？即在这个回滚日志不在被需要的时候，就去删除它。读操作会产生视图，当这个事务结束后该视图删除，那么在这个视图后的回滚日志可以删除，因为已经没有谁会驱动当前版本的数据执行回滚到删除的那个视图版本了。

## 长事务

既然每次提交事务都会都会有着自己的view，那么如果这个事务一直存在而不提交，或着这个事务的存在时间非常长，那么上文提交的`回滚连`不久回长时间存在吗？如果是这样对同一条数据的多次操作不久会使得`回滚链`变得非常长么。我们称这样的事务`为长事务`。 

在实际场景中，本文不推荐使用长事务， 长事务会使得回滚日志变长，可能数据只有1个G，回滚日志有10个G。同时回滚日志还会占据数据库的锁资源等等。

## 启动事务

MySQL事务的启动方式有一下几种：

1. 显示启动事务语句。begin或者start transcation。提交语句为commit，回滚语句为rallback。start transcation命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。 
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此对于一般情况，建议还是使用set autocommit=1，每条语句默认在都在一个单独事务里面且自动提交。

但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用 commit work and chain 语法。在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

````shell
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
````

